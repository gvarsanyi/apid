// Generated by CoffeeScript 1.7.1
var apid, exposed_api, ready, ready_cue, remote_api, started;

exposed_api = require('./lib/exposed-api');

remote_api = require('./lib/remote-api');

started = false;

ready = false;

ready_cue = [];

apid = function(name_id, entry, callback) {
  var file, home, mkdirp;
  if (started) {
    if (typeof callback === "function") {
      callback();
    }
    return;
  }
  started = true;
  if (!(name_id && typeof name_id === 'string')) {
    throw new Error('name_id (first argument) must be a string with contents');
  }
  if (!((entry && typeof entry === 'string') || entry === false)) {
    throw new Error('entry (second argument) must be a file name string');
  }
  if (!((callback == null) || typeof callback === 'function')) {
    throw new Error('callback (last argument) must be a function');
  }
  home = process.env.HOME;
  if (process.platform === 'win32') {
    home = process.env.USERPROFILE;
  }
  home += '/.config/' + name_id;
  file = home + '/apid-' + process.getuid();
  mkdirp = require('mkdirp');
  mkdirp(home, function(err) {
    var connect, connected, daemon, fs, opts, server, type, _fn, _i, _len, _ref, _std_streams;
    connected = function() {
      var cb;
      apid.ready = ready = true;
      while (cb = ready_cue.pop()) {
        cb();
      }
      return typeof callback === "function" ? callback() : void 0;
    };
    if (entry) {
      connect = function(pid) {
        var client;
        client = require('./lib/client');
        return client.connect(file + '.sock', connected);
      };
      daemon = require('daemonize2').setup({
        main: entry,
        name: name_id,
        pidfile: file + '.pid',
        silent: true
      });
      daemon.on('started', connect).on('running', connect).on('error', function(err) {
        throw err;
      });
      return daemon.start();
    } else {
      fs = require('fs');
      opts = {
        encoding: 'utf8',
        flags: 'a'
      };
      _std_streams = {};
      _ref = ['err', 'out'];
      _fn = function(type) {
        return process['std' + type].write = function(d) {
          if (!_std_streams[type]) {
            _std_streams[type] = fs.createWriteStream(file + '.' + type, opts);
            _std_streams[type].once('close', function() {
              return _std_streams[type] = null;
            });
            _std_streams[type].once('error', function() {
              return _std_streams[type] = null;
            });
          }
          return _std_streams[type].write(d);
        };
      };
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        type = _ref[_i];
        _fn(type);
      }
      server = require('./lib/server');
      return server.start(file + '.sock', connected);
    }
  });
};

apid.expose = exposed_api.expose;

apid.exposed = exposed_api.api;

apid.remote = remote_api.api;

apid.ready = ready;

apid.onReady = function(callback) {
  if (ready) {
    callback();
  }
  ready_cue.push(callback);
  return ready;
};

module.exports = apid;
