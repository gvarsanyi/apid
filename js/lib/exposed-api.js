// Generated by CoffeeScript 1.7.1
var api, callbax, expose, expose_hash,
  __slice = [].slice;

callbax = null;

module.exports.api = api = {};

module.exports.session = {};

api.ping = function(cb) {
  return cb(null, 'pong');
};

expose_hash = function(src, keys) {
  var item, key, new_keys, ref;
  for (key in src) {
    ref = src[key];
    new_keys = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = keys.length; _i < _len; _i++) {
        item = keys[_i];
        _results.push(item);
      }
      return _results;
    })();
    new_keys.push(key);
    expose.apply(null, __slice.call(new_keys).concat([ref]));
  }
};

module.exports.expose = expose = function() {
  var fn, key, key_check, keys, last_key, target, _i, _j, _len, _ref;
  keys = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), fn = arguments[_i++];
  if (fn && typeof fn === 'object') {
    return expose_hash(fn, keys);
  }
  if (typeof fn !== 'function') {
    throw new Error('Attached API interfaces must be functions (' + key + ')');
  }
  key_check = function(key) {
    var _ref;
    if (!((key || key === 0) && ((_ref = typeof key) === 'string' || _ref === 'number'))) {
      throw new Error('Invalid API name: ' + keys.join('.'));
    }
  };
  target = api;
  key_check(last_key = keys[keys.length - 1]);
  if (keys.length > 1) {
    _ref = keys.slice(0, keys.length - 1);
    for (_j = 0, _len = _ref.length; _j < _len; _j++) {
      key = _ref[_j];
      key_check(key);
      target = (target[key] != null ? target[key] : target[key] = {});
    }
  }
  target[last_key] = fn;
};

module.exports.reveal = function(socket) {
  var copy_to_map, map;
  copy_to_map = function(src, target) {
    var key, node;
    for (key in src) {
      node = src[key];
      if (node && typeof node === 'object') {
        copy_to_map(node, (target[key] = {}));
      } else {
        target[key] = 1;
      }
    }
  };
  copy_to_map(api, (map = {}));
  return socket.write({
    api: map,
    session: module.exports.session
  });
};

module.exports.request = function(req, socket, target, target_session) {
  var args, cb, err, fn, item;
  if (callbax == null) {
    callbax = require('callbax');
  }
  cb = callbax(function() {
    var args, msg;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    msg = {
      res: {
        id: req.id
      }
    };
    if (args.length) {
      msg.res.args = JSON.stringify(args);
    }
    return socket.write(msg);
  });
  if (target) {
    cb.remote = target;
  }
  if (target_session) {
    cb.session = target_session;
  }
  try {
    if (!((req != null ? req.id : void 0) >= 1)) {
      throw new Error('dropping request with invalid req id:' + req.id);
    }
    if ((args = req.args) != null) {
      args = JSON.parse(args);
      if (!(Array.isArray(args) && args.length)) {
        throw new Error('Invalid arguments: ' + req.args);
      }
    }
    fn = (function() {
      var _i, _len, _ref, _results;
      _ref = req.fn;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        _results.push(item);
      }
      return _results;
    })();
    target = api;
    while (fn.length) {
      if (!(target = target[fn.shift()])) {
        throw new Error('No such exposed method: ' + req.fn);
      }
    }
    if (typeof target !== 'function') {
      throw new Error('No such exposed method: ' + req.fn);
    }
    if (args) {
      return target.apply(null, __slice.call(args).concat([cb]));
    } else {
      return target(cb);
    }
  } catch (_error) {
    err = _error;
    console.error('failed request', req, err);
    return cb(err);
  }
};
